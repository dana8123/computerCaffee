# 20210603 Chapter 04. 알고리즘

이봐 데이빗.. 코드양이 중요한게 아니잖아..약파네..



## 지난 시간에 한 것

- 컴퓨터 내부의 메모리에 대해 배움

- Data structure를 사용할 수 있었음

## 컴퓨터가 할 수 없는 것

눈으로 훑고 자료를 확인하는 것.

## 컴퓨터가 할 수 있는 것

하나하나 열어서 확인하는 것

## Linear Search

하나하나 다 찾아보기

- 정렬되어있는지 아닌지 모르는 상황에서 쓸 수 있는 합리적인 방법

- 의사코드

  ```
  For i from 0 to n–1
  
      If i'th element is 50
  
          Return true
  
  Return false
  ```

  

## Devide and conquered

- 배열이 정렬되어있을 때, 가운데부터 찾기 시작하는 방법 

- 의사코드

  ```
  If no items
  
      Return false
  
  If middle item is 50
  
      Return true
  
  Else if 50 < middle item
  
      Search left half
  
  Else if 50 > middle item
  
      Search right half
  ```

## 생각해보기

#### 만약 정렬되지 않은 배열이 있다면, 선형검색이 빠를까, 이진검색이 빠를까?

정렬되어있지 않은 배열이라면 어떻게 찾든 운에 맡겨야 하기 때문에 단언하기 어렵다고 생각하지만.

무작위 탐색보다는 선형검색이 빠른편일 것 같기도하고.. 크게 의미 없을 것 같다.

## 알고리즘 도표

- 기울기가 크면 클 수록 비효율적인 알고리즘이라고 할 수 있고
- 같은 의미에서 log^n의 경우 복잡도와 상관없이 시간에 영향을 주지않는 좋은 알고리즘이라고 할 수 있다.

## Big-O notation

코드의 효율성을 나타내는 방법

![](https://assets.digitalocean.com/articles/alligator/js/big-o-notation/o-complexity.png)

### O(n)

- 문제의 크기가 점점 커진다면 어차피 두 기울기가 비슷해질 것이므로 여러가지로(숫자대입) 나누는데 큰 의미가 없음

이외의 알고리즘 표기법도 마찬가지로 생각하면 됨.

![](https://he-s3.s3.amazonaws.com/media/uploads/c14cb1f.JPG)

## Omega Ω

가장 베스트 케이스를 표기한 것

#### 가장 좋은 알고리즘은 평균적으로 빠른 알고리즘이다.

### 생각해보기

실행시간의 상한이 낮은 알고리즘이 더 좋을까요? 하한이 낮은 알고리즘이 더 좋을까요?

- 상한이 낮은 알고리즘은 평균적으로 실행시간이 낮다는 이야기이니, 평균적으로 실행시간이 적은 알고리즘이 더 좋은 알고리즘이라고 생각한다.
- 하한이 낮은 알고리즘은 편차가 심한 알고리즘을 포함하는 경우, 평균적인 실행시간이 높아질 수 있기 때문에 비교적 좋지 않은 알고리즘이라고 생각한다.

### 생각해보기

전화번호부와 같이 구조체를 정의하여 관리 및 검색을 하면 더 편리한 예는 또 무엇이 있을까요?

- 교내 학과별 학생 명단
- 요일별 나오는 식단
- 날짜별 스케쥴 리스트
- 제과업체 별 나오는 과자 리스트
- 유저별 인적사항
- 업체별 납품 아이템

등의 연관성 있는 자료는 구조체를 정의하여 관리하면 더 편리할 것 같다.

## 정렬되지 않은 자료 정렬한 후 검색하기 (버블 정렬)

#### 정렬이 될 때 까지 왼쪽의 숫자와 비교하여 바꾸는 것

- N개의 정렬되지 않은 숫자를 정렬하고자 한다.
- 이 때 왼쪽의 숫자와 비교하여 오른쪽의 숫자가 더 크다면 가만히 두고, 작다면 위치를 바꾼다.
- 위의 정렬이 1회 끝나고나면 가장 큰 숫자가 제일 오른쪽으로 오게된다. (총 n-1회 실행)
- 그다음 큰 숫자가 그 옆으로 가려면 같은 행위를 (n-2)회 실행하여야 한다.
- 이 때 총 움직인 횟수는 (n-1)*(n-2)회 이다.

$$
(n-1)*(n-2) = n^2 -3n +2
$$



- 여기서 가장 의미있는 값은 최고차항이기 때문에, 이 알고리즘의 Big O 표기법은 

$$
O(n^2)
$$

라고 표현할 수 있다.

![](https://assets.digitalocean.com/articles/alligator/js/big-o-notation/o-complexity.png)

### 의사코드로 나타내기

```
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

#### 정렬이 되어있는지 여부와 관계 없이, 루프를 돌며 비교를 해야 하므로, 버블정렬의 실행시간의 하한도 **Ω(n^2)** 이다.

### 생각해보기

#### 버블 정렬이 효율적인 경우는 어떤 경우인가요? 반대로 어떤 경우에 비효율적이게 될까요?

- 어느정도 정렬이 되어있는 경우(작은숫자와 큰 숫자별로 나뉘어져있다던지), 운좋게 n-1번을 다 안돌아도 될 때.
- 버블정렬 할 자료 자체가 많지 않은경우
- 정렬이 무작위로 되어있을 경우
- 어차피 큰 의미 없지 않을까? n^2번 돌게되는건 마찬가지일테니.(n <= 2 인 경우를 제외하고는.)

## 선택정렬

#### 정렬이 될 때 까지 가장 작은 숫자를 찾아서 정렬하는 것

- n개의 정렬되지않은 숫자를 정렬하고자 한다.

- n번째의 숫자 중 가장 작은 숫자를 정렬한다

- 그 다음 n-1번째의 숫자 중 가장 작은 숫자를 정렬한ㄷ

- 이 행위는 다음과 같은 수식으로 정리할 수 있다
  $$
  n + (n - 1) + (n -2) + ... + 2 + 1
  $$
  등차수열..개오랜만..

  등차수열 정리하면
  $$
  n(n + 1) / 2
  $$

  - 즉, n^2가 최고차항으로 나타나게된다.
  - 버블정렬과 크게 다르지 않다는 말이다.

  #### 모든 숫자가 정렬되어있는 경우는?

  정렬이 되어있는 경우도 마찬가지로 모든 숫자를 비교하여 가장 작은 숫자인지 확인하는 과정을 거쳐야하므로

  정렬이 되어있건 안되어있건 마찬가지로 로직이 실행된다. 따라서
  $$
  Ω(n^2)
  $$
  의 값을 갖게된다.

### 생각해보기

#### 선택정렬을 좀 더 효율적으로 어떻게 바꿀 수 있을까요?

- 모든 숫자가 다 정렬이 되어있는 경우, 더이상 순회하지 않도록한다.
  - 이 경우 운이 좋으면 n번만 순회해도 될 지도... 그런데 만약 array 내에 어떤 숫자가 어떻게 있는지 알지 못한다면, 이 방법은 실행 불가능 할 것 같다.
- 최솟값을 찾으면서 동시에 최대값도 찾는다.
  - 라는 의견이 에드윅스에 많이 달렸길래 생각해봤는데 이 경우도 마찬가지로 최고차항 2차인 식을 갖게된다.
  - 크게 의미 없어보이는데, 조금 더? 효율적이긴하다. (n/2)만큼.
  - 만약 n의 숫자가 굉장히 크다면 비교적 의미있는 효율을 체감할 수 있을듯.
  - 그런데 너무나 작은.. 차이 이므로 효율적으로 바꿨다 라고 말하기엔 양심에 털났다고 생각한다.

## 알고리즘을 효율적으로 사용할 수 있는 방법

- 이미 정렬이 되어있을 경우 더이상 알고리즘을 실행하지 않는경우를 의미한다.
- 버블정렬의 경우, 이미 모두 정렬이 되어있다면 n-1회만 실행하도록 한다면 실행시간이 획기적으로 줄어든다.

### 생각해보기

#### 선택정렬의 실행시간의 하한도 버블 정렬처럼 더 단축시킬 수 있을까요?

- 아니다. 
- 1회 째 실행할 때 아무 이동이 없었다고 해도, 2회째에서 가장 작은숫자에 대한 이동이 발생할 수 있다.
- 따라서 선택정렬의 경우 버블정렬처럼 단축시키는것이 불가능하다.

## 재귀 함수

자기자신을 호출

### reculsive definition(재귀적 정의)

시작점에서 종료지점까지 반복되는것을 정의한 것

### 마리오 피라미드 그리기_1

```
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int height = get_int("Height : ");

    draw(height)
}
```

### 마리오 피라미드 그리기_2 ( 중첩 for 문을 사용할 경우)

```
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int height = get_int("Height : ");

    draw(height)
}

void draw(int h)
{
    for (int i = 1; i <= h ; i++)
    {
        for(int j =1; j <= i; j++)
        {
            printf("#");
        }
        print("\n");
    }
}
```

- i값을 h값만큼 증가시키고
- i값에 해당하는 j값 만큼 피라미드를 출력한다.
- 꼭 중첩루프를 쓰지 않아도, 한 층을 쌓고나면 그 다음 층을 쌓는것을 반복하므로 반복하는것을 정의하여 코드를 짠다면 중첩문을 쓸 필요가 없다.

### 마리오 피라미드 그리기_3 (재귀함수 사용)

```
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height : ");

    draw(height);
}

void draw(int h)
{
    if( h == 0)
    {
        return;
    }

   draw(h - 1);

   for(int i = 0; i < h; i++)
   {
       printf("#");
   }
   printf("\n"); 
}
```

### 생각해보기

#### 반복문을 쓸 수 있는데도 재귀를 사용하는 이유는 무엇일까?

- 반복문을 사용할 때, 같은 함수를 최소 n번씩 호출하므로, O(n)이상의 값을 가진다.
- 특히 중첩된 반복문을 사용하게된다면, 두번씩 호출하게되므로 O(n^2) 의 값을 가진다.
- 따라서 알고리즘을 푸는데 걸리는 시간을 줄이기 위해 사용한다.

## 재귀를 활용한 정렬문제 풀기

## 병합정렬

왼편 정렬, 오른편 정렬, 머지

- 왼편의 숫자를 정렬한다
- 오른편의 숫자를 정렬한다
-  병합한다.

총 8개인 배열을 정렬하기 위해서

배열의 크기가 1인것부터 시작해서 정렬을 시작하고

그 다음은 배열의 크기가 2인것을 정렬하고

배열의 크기가 4인것을 정렬하고

합친다.

log n의 시간복잡도 그냥 이게 젤 좋은거다.. 하고 받아들이자

### 시간복잡도의 하한선과 상한선이 같을 때 쓰는 기호

$$
Θ
$$







