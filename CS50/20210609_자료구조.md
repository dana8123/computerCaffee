# 20210609 자료구조

- 포인터와 포인티를 생성하는것은 별개의 일이다.
- 포인티가 없는데 역참조(*)하면 실행되지않는다.

CODE

```
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    
    y = x;
    
    *y = 13;
}
```

### 생각해보기

#### 포인터를 초기화시키지 않고 값을 저장하면 어떤 오류가 발생할 수 있을까요?

- 포인터가 가리키는 메모리 주소가 없으므로 할당 할 공간이 없다. 할당되지않는 문제가 발생할 것 같다.

------

## 배열의 크기

### Resizing array

- 더 큰 공간이 있는 메모리에 이동시킨다.
  - Leanear TIME
  - 비효율적

- realloc
  - 메모리 크기를 재할당해줌
  - 이전의 메모리 덩어리는 컴퓨터 어딘가를 떠다니고있지만, 그것을 가리키는 포인터가 없음.

CODE

```
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```

### 생각해보기

#### 이미 할당된 메모리의 크기를 조절할 때 임시 메모리를 새로 할당해줘야 하는 이유는 무엇인가요?

- 더 큰 크기의 메모리로 재할당하려면 주변의 다른 공간이 있거나 해야하는데, 이미 다른 메모리에는 다른 데이터가 할당되어있다.
- 그래서 기존의 데이터를 보존하면서 크기를 조절하려면 새로운 임시메모리를 할당해주어야한다.

## Linked list

- 메모리 덩어리가 연결되어있는 것
- 배열에서는 각 인덱스의 다음 값이 메모리상에 연이어 저장되어있음
- 그러나 그럴 필요 없이, 다음값의 메모리 주소만 알고있으면 여전히 값을 연이어 읽을 수 있음

![](https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png)

- NULL = 0x0

### Node

- 직사각형으로 나타낼 수 있는 메모리 덩어리

```
typedef struct node
{
    int number;
    struct node *next;
}
node;
```

- node내의 next는 다음 node를 가리키는 포인터가 됨.



### 생각해보기

#### 연결 리스트를 배열과 비교했을 때 장단점은 무엇이 있을까요?

연결리스트는 각각의 값이 다음 값을 가리키는 포인터를 갖고있기 때문에, 배열의 크기 재할당에 대한 절차가 없다.

____

## 어디에 쓸까?

#### 고려해야하는 부분

- 정렬을 할 때, 연결이 끊긴다면. 이후의 연결은 모두 lost.

- 이로인해 메모리 누수가 생길 수 있음

  ```
  n->next = list;
  list = n;
  ```

### 생각해보기

#### 연결 리스트의 중간에 node를 추가하거나 삭제하는 코드는 어떻게 작성할 수 있을까요?

## 무엇을 잃었나?

- 임의접근을 할 수 없음
  - 모든 포인터를 다 따라가야하기 때문에
  - 탐색, 삽입이 O(n)의 복잡도를 가짐
- 배열의 경우 임의 접근이 가능하기 때문에 이진검색을 이용하면 O(log n)의 실행시간이 소요되는것에 비해, 불리함
- 데이터구조는 각각의 장단점이 존재한다.

### 생각해보기

#### 배열이 정렬되어 있지 않은 경우의 검색 소요 시간을 연결 리스트의 검색 시간과 비교해보세요.

- 정렬되지않은 배열의 경우 이진검색을 사용할 수 없음
- Leaner search 를 사용함
- O(n)의 시간 복잡도를 가짐
- 연결리스트의 경우에도 O(n)을 갖게됨
- 그러나 연결리스트의 경우 메모리크기의 수정에 용이하기때문에 위의 경우라면 연결리스트를 선택할 것이다.

## 무엇을 얻었나?

- 메모리의 역동성

## 이진트리

- 포잉ㄴ터가 하나만 가리키는게 아닌 두개를 가리키고있는 모습
- 트리에 있는 모든 노드의 왼쪽자식은 작고, 오른쪽 자식은 크다
- 이진탐색을 하기 매우 쉬워짐
- O(log n)
- 재귀에 가장 적합한 방법

![](https://cs50.harvard.edu/x/2020/notes/5/binary_search_tree.png)

```
//이진 검색 트리의 노드 구조체
typedef struct node
{
    // 노드의 값
    int number;

    // 왼쪽 자식 노드
    struct node *left;
 
   // 오른쪽 자식 노드
    struct node *right;
} node;

// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}
```

### 생각해보기

#### 값을 검색할 때 이진 검색 트리가 기본 연결 리스트에 비해 가지는 장점과 단점은 무엇이 있을까요?

- Big O값이 작아진다는 장점
- 말록을 이용해 포인터를 하나 더 할당해야하므로 메모리의 손실이 발생하는 단점

___

## 일정한 시간을 가지는 자료구조

### 해시테이블

- 배열과 연결리스트를 조합한 것

  ![](https://cs50.harvard.edu/x/2020/notes/5/hash_table.png)

- 이상적인 해시함수의 경우 O(1)

- 최악의 경우 O(n)

### 생각해보기

#### 해시 함수는 어떻게 만들 수 있을까요?

- 특정 기준으로 배열을 만든 후, 배열 아래 연결리스트를 생성하는식으로 만들 것 같다..
- 최상위 노드의 집합은 배열로, 하위는 연결리스트로

---

## 트라이

- 노드의 배열

- 글자 수 만큼의 단계를 거치게 됨

- 그만큼 메모리를 사용하게 됨

- 넓고 밀집도가 높은 자료구조임.

  ![](https://cs50.harvard.edu/x/2020/notes/5/trie.png)

### 생각해보기

#### 트라이가 해시 테이블에 비해 가지는 장점과 단점은 무엇일까요?

- 많은 메모리를 잡아먹는다는 단점
- O(constance)의 값을 갖게되어 빠른 처리가 가능하다는 장점

## QUEUE

- FIFO (선입선출)
- Enqueue, Dequeue

## Stack

- Push, POP
- LIFO(후입선출)

## dictionary

- key, value
- 쌍으로 이루어진 자료 구조
- 

