# Node.js 디자인 패턴 바이블
을 읽고 기록한 공간입니다.


## Node.js 철학
### 경량 코어
- 최소한의 기능 세트를 가지고 코어 바깥 부분에 userland, userspace 라고 하는 사용자 전용 모듈 생태계를 둠.
### 경량 모듈
- 애플리케이션과 재사용 가능한 라이브러리를 만들기위한 구성요소인 "모듈"을 사용
- 코드의 양 뿐만 아니라, 범위적 측면에서도 작은 모듈을 디자인 하는 것이 원칙  
    작은 것이 아름답다.  
    각 프로그램은 한가지 역할만 잘 하도록 만들어라
- NPM, yarn 같은 패키지 관리자 사용
- 작고 집중화된 모듈의 장점
    - 재사용성
    - 테스트 및 유지보수가 쉬움
    - 사이즈가 작아 브라우저에 사용하기 용이
### 작은 외부 인터페이스
- 모듈을 정의하는 가장 일반적인 패턴은, 단일 진입점을 제공하는 단 하나의 함수, 클래스를 노출하는 것
- 확장 가능성을 금지하기 위해 모듈 내부 접근을 제한
4. 간결함, 실용주의
- 순수 객체지향 설계는 실제 세계의 복잡성과 불완전성을 고려하지 않는 점

## Node.js는 어떻게 작동하는가
### I/O는 시간이 오래걸린다.
- ram 까지 접근하는 시간은 나노초, 하지만 디스크, 네트워크에 접근하는데에는 밀리초가 걸림
### 블로킹 I/O
- 전통적인 블로킹 프로그래밍은 I/O가 끝나기 전까지 해당 스레드를 블로킹한다.
- 같은 스레드에서 여러 작업을 처리하지 못함
- 연산이 완전히 처리되기 전까지 해당 스레드는 블로킹된 상태이며, 스레드에 대해 유휴시간이 발생한다.
    - 자원낭비 발생
    - 메모리와 CPU 낭비
### 논블로킹 I/O
- 데이터가 연산처리 되기를 기다리지 않고, 즉시 반환됨.
- 호출 순간에 사용할 수 있는 반환결과가 없는 경우, 미리 정의된 상수를 반환.
- 실제 데이터가 반환될 때 까지 루프 내에서 리소스를 폴링함.
    - busy waiting
    - 사용할 수 없는 리소스, 즉 아직 연산처리가 완료되지 않은 리소스들에 대해서도 반복하기 때문에 CPU 시간 낭비
    ```javascript
    resources = [socketA, socketB, fileA]
    while(!resource.isEmpty()) {
        for(resource of resources) {
            // 데이터 읽기를 시도
            data = resource.read()
            if(data === NO_DATA) {
                // 읽을 데이터가 없는 순간
                continue
            }
            if( data === RESOURCE_CLOSED) {
                // 리소스가 닫히고, 리스트에서 삭제
                resources.remove(i)
            } else {
                // 데이터를 받고, 처리
                consumeData(data)
            }
        }
    }
    ```
    ### 이벤트 디멀티플렉싱
    - Busy wating보다 더 효율적인 블로킹 리소스 처리 방법
    - 여러 리소스를 관찰하고, 리소스들 중 읽기, 쓰기 연산의 실행이 완료되었을 때 새로운 이벤트를 반환
    - 새로운 이벤트가 있을 때 까지 블로킹
    ```javascript
    watchedList.add(socketA, FOR_READ)
    watchedList.add(fileB, FOR_READ)
    while(events = demultiplexer.watch(watchedList)) {
        // 이벤트 루프
        for (event of events) {
            // 블로킹하지 않으며, 항상 데이터를 반환
            data = event.resource.read()
        }
    }
    ``` 